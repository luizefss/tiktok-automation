#//var/www/tiktok-automation/backend/advanced_tts.py
"""
advanced_tts.py - Sistema de TTS com Google Cloud e voz humanizada
"""
import os
import logging
from typing import Dict, Optional
from google.cloud import texttospeech
import soundfile as sf
import numpy as np
from scipy import signal
import librosa
import re
from dotenv import load_dotenv

# Configurar logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


class AdvancedTTS:
    def __init__(self):
        load_dotenv()
        
        # Configurar credenciais do Google Cloud
        credentials_path = os.getenv('GOOGLE_APPLICATION_CREDENTIALS', './service-account-key.json')
        if os.path.exists(credentials_path):
            os.environ['GOOGLE_APPLICATION_CREDENTIALS'] = credentials_path
            logger.info(f"üìÅ Usando credenciais: {credentials_path}")
        
        try:
            self.client = texttospeech.TextToSpeechClient()
            logger.info("‚úÖ Cliente do Google Cloud TTS inicializado.")
        except Exception as e:
            logger.error(f"‚ùå Falha ao inicializar cliente do TTS: {e}")
            raise RuntimeError(
                "Verifique se o arquivo service-account-key.json est√° configurado e as APIs est√£o habilitadas.")
        
        # AJUSTES PARA VOZ MAIS HUMANIZADA E NATURAL
        self.voice_profiles = {
            'mysterious': {
                'speaking_rate': 1.05,  # Aumentado de 0.88 para ficar mais natural
                'pitch': -2.5,          # Menos grave (era -2.5)
                'volume_gain_db': 0.5,   # Volume normal
                'voice_id': 'pt-BR-Neural2-B',  # Voz masculina mais natural
                'gender': texttospeech.SsmlVoiceGender.MALE,
                'effects': ['subtle_reverb']  # Reverb mais sutil
            },
            'dramatic': {
                'speaking_rate': 1.02,   # Velocidade quase normal (era 0.94)
                'pitch': -0.5,           # Ligeiramente mais grave
                'volume_gain_db': 1.0,   # Um pouco mais alto
                'voice_id': 'pt-BR-Neural2-A',  # Voz Neural2 mais natural
                'gender': texttospeech.SsmlVoiceGender.MALE,
                'effects': ['light_compression']
            },
            'serious': {
                'speaking_rate': 1.0,    # Velocidade normal
                'pitch': 0.0,            # Tom neutro
                'volume_gain_db': 0.0,
                'voice_id': 'pt-BR-Wavenet-C',
                'gender': texttospeech.SsmlVoiceGender.MALE,
                'effects': []
            },
            'inspiring': {
                'speaking_rate': 1.08,   # Ligeiramente mais r√°pido (era 1.05)
                'pitch': 1.0,            # Tom mais alto mas n√£o exagerado (era 2.0)
                'volume_gain_db': 1.0,
                'voice_id': 'pt-BR-Neural2-B',  # Voz Neural2 feminina natural
                'gender': texttospeech.SsmlVoiceGender.FEMALE,
                'effects': ['warmth']     # Adiciona calor √† voz
            },
            'conversational': {
                'speaking_rate': 1.05,   # Velocidade de conversa natural
                'pitch': 0.5,
                'volume_gain_db': 0.0,
                'voice_id': 'pt-BR-Wavenet-A',
                'gender': texttospeech.SsmlVoiceGender.MALE,
                'effects': []
            }
        }
        
        # Vozes alternativas para variedade
        self.alternative_voices = {
            'male': [
                'pt-BR-Wavenet-B',    # Principal masculina
                'pt-BR-Neural2-A',    # Neural masculina
                'pt-BR-Wavenet-C',    # Alternativa masculina
            ],
            'female': [
                'pt-BR-Neural2-B',    # Principal feminina
                'pt-BR-Wavenet-A',    # Wavenet feminina (sim, A pode ser feminina)
                'pt-BR-Wavenet-F',    # Alternativa feminina
            ]
        }

    def generate_speech(self, text: str, output_path: str,
                        emotion: str = "mysterious",
                        voice_variation: bool = True) -> Optional[str]:
        """
        Gera √°udio humanizado com varia√ß√µes naturais
        
        Args:
            text: Texto para narra√ß√£o
            output_path: Caminho do arquivo de sa√≠da
            emotion: Tipo de emo√ß√£o (mysterious, dramatic, serious, inspiring, conversational)
            voice_variation: Se True, adiciona varia√ß√µes sutis para parecer mais humano
        """
        
        profile = self.voice_profiles.get(emotion, self.voice_profiles['mysterious'])
        
        # Criar SSML com marca√ß√µes humanizadas
        ssml_text = self._create_humanized_ssml(text, emotion, voice_variation)
        
        synthesis_input = texttospeech.SynthesisInput(ssml=ssml_text)
        
        voice_config = texttospeech.VoiceSelectionParams(
            language_code='pt-BR',
            name=profile['voice_id'],
            ssml_gender=profile['gender']
        )
        
        # Configura√ß√£o de √°udio com ajustes para soar mais natural
        audio_config = texttospeech.AudioConfig(
            audio_encoding=texttospeech.AudioEncoding.MP3,
            speaking_rate=profile['speaking_rate'],
            pitch=profile['pitch'],
            volume_gain_db=profile['volume_gain_db'],
            # Adicionar efeitos de √°udio do Google Cloud se dispon√≠veis
            effects_profile_id=['headphone-class-device']  # Otimizado para fones
        )
        
        try:
            logger.info(f"üéôÔ∏è Gerando √°udio com emo√ß√£o '{emotion}'...")
            logger.info(f"   Velocidade: {profile['speaking_rate']}x")
            logger.info(f"   Tom: {profile['pitch']} semitons")
            logger.info(f"   Voz: {profile['voice_id']}")
            
            response = self.client.synthesize_speech(
                input=synthesis_input,
                voice=voice_config,
                audio_config=audio_config
            )
            
            # Garantir que o diret√≥rio existe
            os.makedirs(os.path.dirname(output_path) if os.path.dirname(output_path) else '.', exist_ok=True)
            
            with open(output_path, 'wb') as audio_file:
                audio_file.write(response.audio_content)
            
            # Aplicar efeitos sutis se necess√°rio
            if profile['effects'] and voice_variation:
                self._apply_humanized_effects(output_path, profile['effects'])
            
            logger.info(f"‚úÖ √Åudio gerado com sucesso: {output_path}")
            return output_path
            
        except Exception as e:
            logger.error(f"‚ùå Erro ao gerar √°udio: {e}")
            return None

    def _create_humanized_ssml(self, text: str, emotion: str, add_variations: bool = True) -> str:
        """
        Cria SSML humanizado com pausas naturais e varia√ß√µes sutis
        """
        ssml = '<speak>'
        
        # Dividir em par√°grafos
        paragraphs = text.split('\n\n')
        
        for i, para in enumerate(paragraphs):
            para = para.strip()
            if not para:
                continue
            
            # Dividir em senten√ßas para aplicar varia√ß√µes
            sentences = re.split(r'(?<=[.!?])\s+', para)
            
            for j, sentence in enumerate(sentences):
                if not sentence:
                    continue
                
                # Pausas mais naturais e curtas
                sentence = sentence.replace('...', '<break time="600ms"/>')  # Era 1200ms
                
                # Detectar perguntas para ajustar entona√ß√£o
                is_question = '?' in sentence
                
                # Detectar exclama√ß√µes para adicionar √™nfase
                is_exclamation = '!' in sentence
                
                # √änfase natural para palavras em MAI√öSCULAS
                emphasized = re.findall(r'\b[A-Z]{2,}\b', sentence)
                for word in emphasized:
                    # Usar √™nfase moderada ao inv√©s de forte
                    sentence = sentence.replace(
                        word, f'<emphasis level="moderate">{word.capitalize()}</emphasis>')
                
                # Adicionar v√≠rgulas naturais (pausas muito curtas)
                sentence = sentence.replace(',', ',<break time="200ms"/>')
                
                # Varia√ß√µes sutis de velocidade e tom para cada senten√ßa
                if add_variations:
                    # Pequenas varia√ß√µes aleat√≥rias para parecer mais humano
                    import random
                    rate_variation = random.uniform(-0.05, 0.05)  # ¬±5% de varia√ß√£o
                    pitch_variation = random.uniform(-0.5, 0.5)   # ¬±0.5 semitons
                else:
                    rate_variation = 0
                    pitch_variation = 0
                
                # Ajustar pros√≥dia baseado na emo√ß√£o e tipo de senten√ßa
                if emotion == "mysterious":
                    if is_question:
                        # Perguntas misteriosas sobem no final
                        ssml += f'<prosody rate="{98 + rate_variation}%" pitch="+{1 + pitch_variation}st">{sentence}</prosody>'
                    else:
                        ssml += f'<prosody rate="{98 + rate_variation}%" pitch="-{1 - pitch_variation}st">{sentence}</prosody>'
                        
                elif emotion == "dramatic":
                    if is_exclamation:
                        # Exclama√ß√µes dram√°ticas com mais intensidade
                        ssml += f'<prosody rate="{105 + rate_variation}%" pitch="+{1 + pitch_variation}st" volume="+2dB">{sentence}</prosody>'
                    else:
                        ssml += f'<prosody rate="{102 + rate_variation}%" pitch="-{0.5 - pitch_variation}st">{sentence}</prosody>'
                        
                elif emotion == "inspiring":
                    # Tom inspirador crescente
                    if j == len(sentences) - 1:  # √öltima senten√ßa do par√°grafo
                        ssml += f'<prosody rate="{110 + rate_variation}%" pitch="+{2 + pitch_variation}st" volume="+1dB">{sentence}</prosody>'
                    else:
                        ssml += f'<prosody rate="{108 + rate_variation}%" pitch="+{1 + pitch_variation}st">{sentence}</prosody>'
                        
                elif emotion == "conversational":
                    # Tom conversacional natural
                    ssml += f'<prosody rate="{105 + rate_variation}%" pitch="+{0.5 + pitch_variation}st">{sentence}</prosody>'
                    
                else:  # serious ou default
                    ssml += f'<prosody rate="{100 + rate_variation}%" pitch="{pitch_variation}st">{sentence}</prosody>'
                
                # Pausa natural entre senten√ßas (mais curta que antes)
                if j < len(sentences) - 1:
                    ssml += '<break time="300ms"/>'  # Era 500ms
            
            # Pausa entre par√°grafos (mais curta)
            if i < len(paragraphs) - 1:
                ssml += '<break time="500ms"/>'  # Era 600ms
        
        ssml += '</speak>'
        return ssml

    def _apply_humanized_effects(self, audio_path: str, effects: list):
        """
        Aplica efeitos sutis para humanizar o √°udio
        """
        try:
            # Carregar √°udio
            audio, sr = librosa.load(audio_path, sr=None)
            
            for effect in effects:
                if effect == 'subtle_reverb':
                    # Reverb muito sutil para adicionar espa√ßo
                    impulse = np.zeros(int(0.05 * sr))  # Reverb mais curto
                    impulse[0] = 1
                    for i in range(1, 3):  # Menos reflex√µes
                        impulse[int(i * 0.01 * sr)] = 0.3 ** i
                    audio = signal.convolve(audio, impulse, mode='same')
                    
                elif effect == 'light_compression':
                    # Compress√£o suave para uniformizar volume
                    threshold = 0.7
                    ratio = 2  # Ratio mais suave
                    audio = np.where(
                        np.abs(audio) > threshold,
                        threshold + (audio - threshold) / ratio,
                        audio
                    )
                    
                elif effect == 'warmth':
                    # Adiciona calor com boost suave nos m√©dios
                    sos = signal.butter(2, [200, 2000], 'band', fs=sr, output='sos')
                    mid_freq = signal.sosfilt(sos, audio)
                    audio = audio + (mid_freq * 0.1)  # Boost muito sutil
                    
                elif effect == 'low_pass':
                    # Filtro passa-baixa suave
                    sos = signal.butter(4, 4000, 'low', fs=sr, output='sos')  # Frequ√™ncia mais alta
                    audio = signal.sosfilt(sos, audio)
                    
                elif effect == 'brightness':
                    # Adiciona brilho sutil
                    sos = signal.butter(2, 6000, 'high', fs=sr, output='sos')
                    high_freq = signal.sosfilt(sos, audio)
                    audio = audio + (high_freq * 0.1)  # Boost muito sutil
            
            # Normalizar mantendo din√¢mica
            max_val = np.max(np.abs(audio))
            if max_val > 0:
                audio = audio * (0.95 / max_val)  # Deixar um pouco de headroom
            
            # Salvar √°udio processado
            sf.write(audio_path, audio, sr)
            logger.info("‚úÖ Efeitos humanizados aplicados ao √°udio")
            
        except Exception as e:
            logger.warning(f"‚ö†Ô∏è N√£o foi poss√≠vel aplicar efeitos: {e}")


def test_tts():
    """Fun√ß√£o de teste do TTS humanizado"""
    print("\n" + "="*60)
    print("üéôÔ∏è TESTE DO TTS HUMANIZADO")
    print("="*60 + "\n")
    
    tts = AdvancedTTS()
    
    # Texto de teste com diferentes emo√ß√µes
    test_text = """
    Voc√™ j√° se perguntou sobre os mist√©rios do universo?
    
    Hoje vamos explorar algo INCR√çVEL... Prepare-se para uma jornada fascinante!
    
    A verdade pode ser mais surpreendente do que voc√™ imagina.
    """
    
    # Testar diferentes emo√ß√µes
    emotions = ['mysterious', 'dramatic', 'conversational']
    
    for emotion in emotions:
        output = f"test_audio_{emotion}.mp3"
        print(f"Gerando √°udio com emo√ß√£o: {emotion}")
        result = tts.generate_speech(test_text, output, emotion=emotion)
        if result:
            print(f"‚úÖ √Åudio salvo: {output}")
        else:
            print(f"‚ùå Falha ao gerar √°udio {emotion}")
        print("-"*40)


if __name__ == "__main__":
    test_tts()